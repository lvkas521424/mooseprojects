# UserObject 到 MultiApp 的参数传递机制

## 概述

本文档说明如何从 `ReactorCouplingUserObject` 向 `NeutronicsMultiApp` 传递计算参数。

## 实现原理

### 1. UserObject 提供公共访问接口

在 `ReactorCouplingUserObject.h` 中添加公共方法：

```cpp
/**
 * 公共访问接口：获取计算类型
 */
unsigned int getCalcType() const { return _calc_type; }

/**
 * 公共访问接口：获取当前燃耗步
 */
unsigned int getBurnStep() const { return _burn_step; }
```

### 2. MultiApp 引用 UserObject

在输入文件中配置 `NeutronicsMultiApp` 时，通过 `coupling_userobject` 参数引用：

```
[MultiApps]
  [neutronics]
    type = NeutronicsMultiApp
    coupling_userobject = 'coupling_control'  # 引用 UserObject 名称
    # ... 其他参数
  []
[]
```

### 3. MultiApp 获取并使用参数

在 `NeutronicsMultiApp::executeB1Solver()` 中：

```cpp
// 从 ReactorCouplingUserObject 获取计算参数
if (!_coupling_userobject_name.empty() && _fe_problem.hasUserObject(_coupling_userobject_name))
{
    const auto& coupling_uo = _fe_problem.getUserObject<ReactorCouplingUserObject>(_coupling_userobject_name);
    calc_type = coupling_uo.getCalcType();
    burn_step = coupling_uo.getBurnStep();
}
```

## 使用方法

### 方法1: 静态配置（不使用 UserObject）

直接在 MultiApp 中设置参数：

```
[MultiApps]
  [neutronics]
    type = NeutronicsMultiApp
    calc_type = COUPLED  # 静态设置
    # ...
  []
[]
```

**优点**: 简单直接  
**缺点**: 参数固定，无法在运行时动态调整

### 方法2: 动态获取（通过 UserObject）⭐ 推荐

通过 UserObject 引用获取参数：

```
[UserObjects]
  [coupling_control]
    type = ReactorCouplingUserObject
    calc_type = COUPLED
    burn_step = 1
    # ...
  []
[]

[MultiApps]
  [neutronics]
    type = NeutronicsMultiApp
    coupling_userobject = 'coupling_control'  # 引用 UserObject
    # ...
  []
[]
```

**优点**: 
- 参数可以在 UserObject 中动态更新
- 多个 MultiApp 可以共享同一个 UserObject
- 更好的代码组织和参数管理

**缺点**: 配置稍微复杂一点

## 可传递的参数

目前支持传递以下参数：

1. **calc_type** - 计算类型
   - `1` = 仅中子学计算
   - `2` = 耦合计算

2. **burn_step** - 当前燃耗步数
   - 整数值，表示当前的燃耗步

## 扩展方法

如果需要传递更多参数，可以在以下位置添加：

1. **在 ReactorCouplingUserObject.h 中添加 getter 方法**:
   ```cpp
   Real getConvergenceTolerance() const { return _coupling_tolerance; }
   ```

2. **在 NeutronicsMultiApp.C 中获取参数**:
   ```cpp
   Real tolerance = coupling_uo.getConvergenceTolerance();
   ```

## 运行时输出

当 MultiApp 从 UserObject 获取参数时，会输出以下信息：

```
========================================
  中子学求解器 [步数: 1, 时间: 1.0 s, 燃耗步: 1]
========================================
  从UserObject获取参数:
    - 计算类型: 耦合计算
    - 燃耗步数: 1
  MPI进程数: 4, 全局网格点: 1000
  开始B1并行计算...
  B1计算完成！
========================================
```

## 注意事项

1. UserObject 必须在 MultiApp 之前定义
2. UserObject 的 `execute_on` 时机应早于或等于 MultiApp
3. 确保 UserObject 名称与 `coupling_userobject` 参数中的名称一致
4. 如果 UserObject 不存在，MultiApp 会使用自身的默认参数

## 示例文件

完整的示例配置文件请参考：
- `examples/parameter_passing_example.i`

